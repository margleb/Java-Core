/*
Рискуя на себя навлечь обвинения в сексизме, таки не удержусь и приведу пример атомарной операции: беременность - операция строго атомарная, всегда есть один и только один отец (всякие генные ухищрения вынесем за скобки).
И наоборот пример неатомарной операции: воспитание ребенка - увы операция неатомарная, ребенок есть к сожалению субъект множества различных несинхронизированных операций над неокрепшей душой ребенка: мама, папа, бабушка, дедушка, зомбоящик, детсад, школа, друзья, подруги и т.д. по списку.

Если убрать Thread.sleep то операция остается отомарной, просто не все данные успевают посчитаться,
и соответсвенно нам выводятся данные не конечные, а в отдельном потоке переменная i все еще увеличивается до 10 тысяч.

Volotile - Это означает, что значение переменной будет "всегда читаться".
Например, в многопоточных приложениях один поток прочёл значение a=1, передал управление другому потоку, который изменил значение на a=2, потом управление вернулось. Так вот, без volatile значение a у первого потока будет 1, т.к. первый поток "помнит", что a=1, с volatile - 2, т.к. первый поток снова прочтет значение и получит уже измененное.

*/

import java.util.concurrent.atomic.AtomicInteger;

public class Main {

    static int i;
    static AtomicInteger atomicInteger = new AtomicInteger(0);
    public static void main(String[] args) throws InterruptedException {
        for(int i = 0; i < 100_000; i++) {
            new MyThread().start();
        }
        Thread.sleep(2_000);
        System.out.println(i);
        // sSystem.out.println(atomicInteger.get());
    }

    static class MyThread extends Thread {
        @Override
        public void run() {
            // 1. int k = i + 1; // i = 4; k = 5
                // 1. int k = i + 1; // i = 4; k = 5;
                // 2. i = k // i = 5;
            // 2. i = k; // i = 5;
            i++;
            atomicInteger.incrementAndGet();
        }
    }

}
